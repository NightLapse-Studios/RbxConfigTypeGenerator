--!strict

local CONFIG = {
	-- Suffix for generated types to avoid collisions
	TypeSuffix = "Cfg",
	IgnoreDeprecatedMembers = true,
	IgnoreDeprecatedClasses = true,
	GenerateTypesFile = true,
	-- Does a second pass that outputs a list of types associated
	-- with each particular member string
	AmbiguousMembersHelperFile = "combined_members.txt",
	-- Reserialize the API dump to dump.json
	APIFetchDumpFile = false,
	-- Bypass fetching with this file instead
	APIFetchCacheFile = true
}

local fs = require("@lune/fs")
local net = require("@lune/net")
local serde = require("@lune/serde")

local APITypes = require("./ApiTypes")

local GET_VERSION_URL = "https://setup.rbxcdn.com/versionQTStudio"
local GET_API_JSON_URL = "https://setup.rbxcdn.com/%s-API-Dump.json"

local TYPES_HEADER = [[
-- File generated by RbxConfigTypeGenerator
-- Roblox API version %s

type Content = string
type ProtectedString = string
type BinaryString = string
type OptionalCoordinateFrame = CFrame?
type Objects = { Instance }
]]

local BAD_SECURITIES = {
	RobloxScriptSecurity = true,
	CoreScript = true,
	Plugin = true,
}


local function get_rbx_version(): string
	local res = net.request({
		url = GET_VERSION_URL,
		method = "GET"
	})

	return res.body
end

local function get_api(version): APITypes.API
	local url = string.format(GET_API_JSON_URL, version)

	local res = net.request({
		url = url,
		method = "GET"
	})

	return serde.decode("json", res.body)
end

local RbxVersion: string = get_rbx_version()
local API: APITypes.API
local ClassLookup: { [string]: APITypes.Class } = { }
local SubclassList: { [string]: { APITypes.Class }? } = { }

do
	if CONFIG.APIFetchCacheFile then
		local cache_dir_exists = fs.isDir("fetch_cache")
		if not cache_dir_exists then
			error("Fetch cache enabled but no cache directory exists\nPlease navigate to a suitable CWD and create `fetch_cache` directory\n\t(this is not done automatically to avoid over-engineering a standard cache location)")
		end

		local cur_cache_file = `fetch_cache/{RbxVersion}.json`
		local cache_exists = fs.isFile(cur_cache_file)
		if cache_exists then
			API = serde.decode("json", fs.readFile(cur_cache_file))
		else
			for i,v in fs.readDir("fetch_cache") do
				fs.removeFile("fetch_cache/" .. v)
			end

			API = get_api(RbxVersion)
			fs.writeFile(cur_cache_file, serde.encode("json", API, true))
		end
	else
		API = get_api(RbxVersion)
	end

	assert(API.Version == 1, "API Version is not 1")
	
	-- do some preprocessing so that culling classes can cull non-creatable ones which are
	-- only inherited by non-creatable ones
	for i,v in API.Classes do
		ClassLookup[v.Name .. CONFIG.TypeSuffix] = v
	end

	for i,v in API.Classes do
		if not v.Superclass then continue end

		local super_name = v.Superclass .. CONFIG.TypeSuffix
		SubclassList[super_name] = SubclassList[super_name] or { }
		local list = SubclassList[super_name]
		assert(list)

		table.insert(list, v)
	end
end



local function has_bad_security(m: APITypes.Member): boolean
	if m.MemberType == "Property" then
		return BAD_SECURITIES[m.Security.Write]
	else
		return BAD_SECURITIES[m.Security]
	end
end

local function has_tag(m: APITypes.Member | APITypes.Class, tag: string): boolean
	if m.Tags then
		return table.find(m.Tags, tag) ~= nil
	else
		return false
	end
end

local PRIMITIVE_MAP = {
	bool = "boolean",
	double = "number",
	float = "number",
	int = "number",
	int64 = "number",
	string = "string",
	["string?"] = "string?",
	["null"] = "()"
}

local GROUP_MAP = {
	Array = "{ [number]: any }",
	["Array?"] = "{ [number]: any }?",
	Dictionary = "{ [string]: any }",
	["Dictionary?"] = "{ [string]: any }?",
	Variant = "any",
	["Variant?"] = "any?",
	Tuple = "...any",
	Map = "{ [unknown]: unknown }"
}

local VALUETYPE_CATEGORY_MAP: { [string]: (v: APITypes.ValueType) -> string } = {
	Primitive = function(v: APITypes.ValueType)
		return PRIMITIVE_MAP[v.Name]
	end,
	Enum = function(v: APITypes.ValueType)
		return "Enum." .. v.Name
	end,
	Class = function(v: APITypes.ValueType)
		return v.Name
	end,
	DataType = function(v: APITypes.ValueType)
		return v.Name
	end,
	Group = function(v: APITypes.ValueType)
		return GROUP_MAP[v.Name]
	end
}

local function property_valuetype_to_luau_type(value_type: APITypes.ValueType): string
	local a = VALUETYPE_CATEGORY_MAP[value_type.Category](value_type)
	if not a then print(value_type) end
	return VALUETYPE_CATEGORY_MAP[value_type.Category](value_type)
end

local function params_to_luau_type(params: APITypes.ParamList)
	local out = "("

	for i = 1, #params do
		local p = params[i]
		local t = property_valuetype_to_luau_type(p.Type)

		if i > 1 and i <= #params then
			out ..= ", "
		end

		if p.Type.Name == "Tuple" then
			out ..= "...any"
		else
			out ..= p.Name .. ": " .. t
		end
	end

	out ..= ")"
	return out
end

local function event_to_luau_type(event: APITypes.Event): string
	local params = params_to_luau_type(event.Parameters)
	params ..= " -> (),"
	return params
end

local function callback_to_luau_type(callback: APITypes.Callback): string
	local params = params_to_luau_type(callback.Parameters)
	local ret = property_valuetype_to_luau_type(callback.ReturnType)

	return params .. " -> (" .. ret .. "),"
end

local function member_rhs(member: APITypes.Member): string?
	local rhs = nil
	if member.MemberType == "Property" then
		if has_tag(member, "ReadOnly") then
			return nil
		end

		rhs = property_valuetype_to_luau_type(member.ValueType) .. ","
	elseif member.MemberType == "Event" then
		rhs = event_to_luau_type(member)
	elseif member.MemberType == "Callback" then
		rhs = callback_to_luau_type(member)
	else
		return nil
	end

	return rhs
end

local function member_is_configurable(member: APITypes.Member): boolean
	if has_bad_security(member) then
		return false
	end

	if has_tag(member, "NotScriptable") or has_tag(member, "ReadOnly") then
		return false
	elseif CONFIG.IgnoreDeprecatedMembers and has_tag(member, "Deprecated") then
		return false
	end

	return true
end

-- Returns the type of a member with field name and trailing comma
local function member_to_luau_type(member: APITypes.Member): string?
	if not member_is_configurable(member) then
		return nil
	end

	local rhs = member_rhs(member)
	if not rhs then
		return nil
	end

	return "\t" .. member.Name .. ": " .. rhs
end

local function class_group_is_creatable(c: APITypes.Class): boolean
	if has_tag(c, "NotCreatable") then
		local name = c.Name .. CONFIG.TypeSuffix
		if SubclassList[name] then

			local has_creatable_subclass
			for i,v in SubclassList[name] do
				if has_tag(v, "NotCreatable") then
					has_creatable_subclass = class_group_is_creatable(ClassLookup[v.Name .. CONFIG.TypeSuffix])
					if has_creatable_subclass then
						break
					end
				else
					has_creatable_subclass = true
					break
				end
			end

			if not has_creatable_subclass then
				return false
			end
		else
			return false
		end
	end

	return true
end

local function class_group_has_members(c: APITypes.Class): boolean
	if #c.Members ~= 0 then
		for i,v in c.Members do
			if member_is_configurable(v) then
				return true
			end
		end
	end

	local subclasses = SubclassList[c.Name .. CONFIG.TypeSuffix]
	if not subclasses then
		return false
	end

	for i,v in subclasses do
		if class_group_has_members(v) then
			return true
		end
	end

	return false
end

local function cull_classes(api: APITypes.API)
	local Stripped = { }

	for i,v in API.Classes do
		if has_tag(v, "Service") or has_tag(v, "Settings") then
			continue
		end

		if not class_group_has_members(v) then
			continue
		end

		if not class_group_is_creatable(v) then
			continue
		end

		table.insert(Stripped, v)
	end

	return Stripped
end

-- Primary useful function
local function generate_types()
	-- Strip classes that make no sense to configure
	-- atm this is just services
	local ClassesAfterStripping = cull_classes(API)

	-- Begin printing the file
	local out = string.format(TYPES_HEADER, RbxVersion)

	-- Print individual classes
	for i,v in ClassesAfterStripping do
		local members = ""
		for _, m in v.Members do
			local t = member_to_luau_type(m)
			if not t then continue end

			members ..= t .. "\n"
		end

		-- Detect if a valid superclass should union the type
		-- Some superclasses may be e.g. "<<<ROOT>>>" which corresponds to nothing
		local superclass_name = v.Superclass .. CONFIG.TypeSuffix
		local superclass = if ClassLookup[superclass_name] then superclass_name .. " & " else ""

		local out_class = `export type {v.Name .. CONFIG.TypeSuffix} = {superclass}\{\n{members}\}\n`
		out ..= out_class
	end

	-- Export a type that describes a function which takes a string
	-- and returns a function which takes an configuration for that specific class
	-- then returns that instance class.
	-- This type is in line with what Vide uses for Vide.create
	out ..= "export type InstanceConfigureFactory ="
	for i = 1, #ClassesAfterStripping, 1 do
		local v = ClassesAfterStripping[i]
		if has_tag(v, "NotCreatable") then
			continue
		elseif CONFIG.IgnoreDeprecatedClasses and has_tag(v, "Deprecated") then
			continue
		end

		local s = `(("{v.Name}") -> ({v.Name .. CONFIG.TypeSuffix}) -> {v.Name})`

		if i < #ClassesAfterStripping then
			s ..= " &\n"
		end

		out ..= s
	end

	return out
end


-- Tells which types can be associated with member names
-- if we did not know what class was being handled
-- Output is just text meant for human reading
local function combine_member_types()
	local Stripped = cull_classes(API)
	local Members = { }

	for i,v in Stripped do
		for _, m in v.Members do
			Members[m.Name] = Members[m.Name] or { }
			local list = Members[m.Name]
			
			local t = member_rhs(m)

			local found = false
			for i,v in list do
				if v == t then
					found = true
					break
				end
			end

			if found then
				continue
			end

			if t then
				table.insert(list, t)
			end
		end
	end

	local member_ct = 0
	local out = ""

	for i,v in Members do
		if #v == 0 then
			continue
		end

		member_ct += 1
		out ..= `{i} = \{\n`

		for _, t in v do
			out ..= "\t" .. t .. "\n"
		end

		out ..= "}\n\n"
	end

	print("Total members: ", member_ct)

	return out
end

-- Debug function
local function dump_ValueTypes()
	local Output = { }
	local Collisions = { }

	for i,v in API.Classes do
		for _, m in v.Members do
			if m.MemberType == "Property" then
				if Output[m.ValueType.Name] and Output[m.ValueType.Name] ~= m.ValueType.Category then
					Collisions[m.ValueType.Name] = m.ValueType.Category
				end
				Output[m.ValueType.Name] = m.ValueType.Category
			end
		end
	end

	print(Output)
	print(Collisions)
end

-- Debug function
local function dump_ValueTypes_by_category()
	local Output = { }

	for i,v in API.Classes do
		for _, m in v.Members do
			if m.MemberType == "Property" then
				Output[m.ValueType.Category] = Output[m.ValueType.Category] or { }
				Output[m.ValueType.Category][m.ValueType.Name] = true
			end
		end
	end

	print(Output)
end



if typeof(CONFIG.AmbiguousMembersHelperFile) == "string" then
	fs.writeFile(CONFIG.AmbiguousMembersHelperFile, combine_member_types())
	print("Wrote member types helper file to", CONFIG.AmbiguousMembersHelperFile)
end

if typeof(CONFIG.GenerateTypesFile) then
	fs.writeFile("out.luau", generate_types())
	print("Wrote types file to out.luau")
end

