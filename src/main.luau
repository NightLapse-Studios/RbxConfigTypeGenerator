--!strict

local CONFIG = {
	-- Reserialize the API dump to dump.json
	WriteDumpToFile = true,
	-- Suffix for generated types to avoid collisions
	TypeSuffix = "Cfg",
	IgnoreDeprecatedMembers = true,
	IgnoreDeprecatedClasses = true
}

local fs = require("@lune/fs")
local net = require("@lune/net")
local serde = require("@lune/serde")

local APITypes = require("./ApiTypes")

local GET_VERSION_URL = "https://setup.rbxcdn.com/versionQTStudio"
local GET_API_JSON_URL = "https://setup.rbxcdn.com/%s-API-Dump.json"

local TYPES_HEADER = [[
-- File generated by RbxConfigTypeGenerator
-- Roblox API version %s

type Content = string
type ProtectedString = string
type BinaryString = string
type OptionalCoordinateFrame = CFrame?
type Objects = { Instance }
]]

local function get_rbx_version(): string
	local res = net.request({
		url = GET_VERSION_URL,
		method = "GET"
	})

	return res.body
end

local function get_api(version): APITypes.API
	local url = string.format(GET_API_JSON_URL, version)

	local res = net.request({
		url = url,
		method = "GET"
	})

	return serde.decode("json", res.body)
end


local RbxVersion = get_rbx_version()
local API = get_api(RbxVersion)
assert(API.Version == 1, "API Version is not 1")

local BAD_SECURITIES = {
	RobloxScriptSecurity = true,
	CoreScript = true,
	Plugin = true,
}

local function has_bad_security(m: APITypes.Member): boolean
	if m.MemberType == "Property" then
		return BAD_SECURITIES[m.Security.Write]
	else
		return BAD_SECURITIES[m.Security]
	end
end

local function has_tag(m: APITypes.Member | APITypes.Class, tag: string): boolean
	if m.Tags then
		return table.find(m.Tags, tag) ~= nil
	else
		return false
	end
end

local PRIMITIVE_MAP = {
	bool = "boolean",
	double = "number",
	float = "number",
	int = "number",
	int64 = "number",
	string = "string",
	["string?"] = "string?",
	["null"] = "()"
}

local GROUP_MAP = {
	Array = "{ [number]: any }",
	["Array?"] = "{ [number]: any }?",
	Dictionary = "{ [string]: any }",
	["Dictionary?"] = "{ [string]: any }?",
	Variant = "any",
	["Variant?"] = "any?",
	Tuple = "...any",
	Map = "{ [unknown]: unknown }"
}

local VALUETYPE_CATEGORY_MAP: { [string]: (v: APITypes.ValueType) -> string } = {
	Primitive = function(v: APITypes.ValueType)
		return PRIMITIVE_MAP[v.Name]
	end,
	Enum = function(v: APITypes.ValueType)
		return "Enum." .. v.Name
	end,
	Class = function(v: APITypes.ValueType)
		return v.Name
	end,
	DataType = function(v: APITypes.ValueType)
		return v.Name
	end,
	Group = function(v: APITypes.ValueType)
		return GROUP_MAP[v.Name]
	end
}

local function property_valuetype_to_luau_type(value_type: APITypes.ValueType): string
	local a = VALUETYPE_CATEGORY_MAP[value_type.Category](value_type)
	if not a then print(value_type) end
	return VALUETYPE_CATEGORY_MAP[value_type.Category](value_type)
end

local function params_to_luau_type(params: APITypes.ParamList)
	local out = "("

	for i = 1, #params do
		local p = params[i]
		local t = property_valuetype_to_luau_type(p.Type)

		if i > 1 and i <= #params then
			out ..= ", "
		end

		if p.Type.Name == "Tuple" then
			out ..= "...any"
		else
			out ..= p.Name .. ": " .. t
		end
	end

	out ..= ")"
	return out
end

local function event_to_luau_type(event: APITypes.Event): string
	local params = params_to_luau_type(event.Parameters)
	params ..= " -> (),"
	return params
end

local function callback_to_luau_type(callback: APITypes.Callback): string
	local params = params_to_luau_type(callback.Parameters)
	local ret = property_valuetype_to_luau_type(callback.ReturnType)

	return params .. " -> (" .. ret .. "),"
end

-- Returns the type of a member with field name and trailing comma
local function member_to_luau_type(member: APITypes.Member): string?
	if has_bad_security(member) then
		return nil
	end

	if has_tag(member, "NotScriptable") then
		return nil
	elseif CONFIG.IgnoreDeprecatedMembers and has_tag(member, "Deprecated") then
		return nil
	end

	local rhs
	if member.MemberType == "Property" then
		if has_tag(member, "ReadOnly") then
			return nil
		end

		rhs = property_valuetype_to_luau_type(member.ValueType) .. ","
	elseif member.MemberType == "Event" then
		rhs = event_to_luau_type(member)
	elseif member.MemberType == "Callback" then
		rhs = callback_to_luau_type(member)
	else
		return nil
	end

	return "\t" .. member.Name .. ": " .. rhs
end

-- Primary useful function
local function dump_luau_types()
	local ClassLookup = { }

	for i,v in API.Classes do
		ClassLookup[v.Name .. CONFIG.TypeSuffix] = v
	end

	-- Strip classes that make no sense to configure
	-- atm this is just services
	local ClassesAfterStripping = { }
	for i,v in API.Classes do
		if has_tag(v, "Service") then
			continue
		end

		table.insert(ClassesAfterStripping, v)
	end

	-- Begin printing the file
	print(string.format(TYPES_HEADER, RbxVersion))

	-- Print individual classes
	for i,v in ClassesAfterStripping do
		local members = ""
		for _, m in v.Members do
			local t = member_to_luau_type(m)
			if not t then continue end

			members ..= t .. "\n"
		end

		-- Detect if a valid superclass should union the type
		-- Some superclasses may be e.g. "<<<ROOT>>>" which corresponds to nothing
		local superclass_name = v.Superclass .. CONFIG.TypeSuffix
		local superclass = if ClassLookup[superclass_name] then superclass_name .. " & " else ""

		local out_class = `export type {v.Name .. CONFIG.TypeSuffix} = {superclass}\{\n{members}\}\n`
		print(out_class)
	end

	-- Export a type that describes a function which takes a string
	-- and returns a function which takes an configuration for that specific class
	-- then returns that instance class.
	-- This type is in line with what Vide uses for Vide.create
	print("export type InstanceConfigureFactory =")
	for i = 1, #ClassesAfterStripping, 1 do
		local v = ClassesAfterStripping[i]
		if has_tag(v, "NotCreatable") then
			continue
		elseif CONFIG.IgnoreDeprecatedClasses and has_tag(v, "Deprecated") then
			continue
		end

		local s = `(("{v.Name}") -> ({v.Name .. CONFIG.TypeSuffix}) -> {v.Name})`

		if i < #ClassesAfterStripping then
			s ..= " &"
		end

		print(s)
	end
end

-- Debug function
local function dump_ValueTypes()
	local Output = { }
	local Collisions = { }

	for i,v in API.Classes do
		for _, m in v.Members do
			if m.MemberType == "Property" then
				if Output[m.ValueType.Name] and Output[m.ValueType.Name] ~= m.ValueType.Category then
					Collisions[m.ValueType.Name] = m.ValueType.Category
				end
				Output[m.ValueType.Name] = m.ValueType.Category
			end
		end
	end

	print(Output)
	print(Collisions)
end

-- Debug function
local function dump_ValueTypes_by_category()
	local Output = { }

	for i,v in API.Classes do
		for _, m in v.Members do
			if m.MemberType == "Property" then
				Output[m.ValueType.Category] = Output[m.ValueType.Category] or { }
				Output[m.ValueType.Category][m.ValueType.Name] = true
			end
		end
	end

	print(Output)
end

-- Generally used for debugging, better than printing because of table nesting truncation
if CONFIG.WriteDumpToFile then
	fs.writeFile("dump.json", serde.encode("json", API, true))
end


dump_luau_types()
