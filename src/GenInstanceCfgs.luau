--!strict
--!native

local ApiTools = require("ApiTools")
local ApiTypes = require("ApiTypes")
local GenCommon = require("GenCommon")
local Runtime = require("Runtime")

local TYPES_HEADER = [[
-- File generated by RbxConfigTypeGenerator
-- Roblox API version %s

type Content = string
type ProtectedString = string
type BinaryString = string
type OptionalCoordinateFrame = CFrame?
type Objects = { Instance }
]]

local function generate_types()
    local leaf_classes = Runtime.LeafClasses

    local leaf_count = 0
    for i,v in leaf_classes do
        leaf_count += 1
    end

	-- Begin printing the file
	local out = string.format(TYPES_HEADER, Runtime.RbxVersion)

	-- Print individual classes
	for i,v in leaf_classes do
		local members = ""
		for _, m in v.Members do
			local t = GenCommon.member_to_luau_type(m)
			if not t then continue end

			members ..= t .. "\n"
		end

		-- Detect if a valid superclass should union the type
		-- Some superclasses may be e.g. "<<<ROOT>>>" which corresponds to nothing
		local superclass_name = v.Superclass
		local superclass = if Runtime.ClassLookup[superclass_name] then superclass_name .. " & " else ""

		local out_class = `export type {v.Name .. Runtime.TypeSuffix} = {superclass}\{\n{members}\}\n`
		out ..= out_class
	end

	-- Export a type that describes a function which takes a string
	-- and returns a function which takes an configuration for that specific class
	-- then returns that instance class.
	-- This type is in line with what Vide uses for Vide.create
	out ..= "export type InstanceConfigureFactory ="
    local i = 0
	for _, v in leaf_classes do
        i += 1
		if ApiTools.has_tag(v, "NotCreatable") then
			continue
		elseif Runtime.IgnoreDeprecatedClasses and ApiTools.has_tag(v, "Deprecated") then
			continue
		end

		local s = `(("{v.Name}") -> ({v.Name .. Runtime.TypeSuffix}) -> {v.Name})`

		if i < leaf_count then
			s ..= " &\n"
		end

		out ..= s
	end

	return out
end

return generate_types